# ROS2 C++ 服务端学习笔记 - 人脸检测服务

## 一、ROS2 服务（Service）概念

### 1.1 什么是服务？

服务是 ROS2 中的一种**请求-响应**通信模式。就像去餐厅点餐：
- 你（客户端）向服务员（服务端）**发送请求**（点一份牛排）
- 服务员处理后**返回响应**（把牛排端给你）
- 这是一次**一对一、同步**的交互

```
┌──────────┐    Request     ┌──────────┐
│          │ ─────────────> │          │
│  客户端   │                │  服务端   │
│ (Client) │ <───────────── │ (Server) │
└──────────┘    Response    └──────────┘
```

### 1.2 服务 vs 话题（Topic）

| 对比项 | 服务（Service） | 话题（Topic） |
|--------|----------------|---------------|
| 通信模式 | 请求-响应（一问一答） | 发布-订阅（持续广播） |
| 同步性 | 同步，等待响应 | 异步，发了就不管 |
| 关系 | 一对一 | 一对多、多对多 |
| 适用场景 | 需要结果的单次操作 | 持续的数据流 |
| 例子 | 人脸检测、获取参数 | 传感器数据、摄像头图像 |

### 1.3 什么时候用服务？

✅ **适合用服务的场景：**
- 需要**等待处理结果**（如：检测人脸后要知道检测到几张）
- **偶发性**操作（如：拍照、保存文件）
- **配置/查询**操作（如：获取机器人状态）

❌ **不适合用服务的场景：**
- 高频率持续数据（如：每秒30帧的摄像头图像 → 用话题）
- 不需要响应的单向通知（如：日志广播 → 用话题）

### 1.4 服务的组成

一个完整的服务包含三部分：

```
服务定义文件 (.srv)
├── 请求部分 (Request)    # 客户端发给服务端的数据
├── ---                   # 分隔符
└── 响应部分 (Response)   # 服务端返回给客户端的数据
```

### 1.5 服务端的职责

服务端就像一个**待命的工人**：
1. **启动时**：向 ROS2 注册自己，说"我能提供 xxx 服务"
2. **等待中**：持续运行，等待客户端的请求
3. **收到请求**：执行回调函数，处理请求数据
4. **处理完成**：将结果填入响应，返回给客户端
5. **继续等待**：回到等待状态，准备处理下一个请求

---

## 二、项目背景

基于 OpenCV 的人脸检测功能，封装成 ROS2 服务端，接收图片数据并返回检测结果。

---

## 三、服务接口定义

文件：`chapt4_interface/srv/FaceDetector.srv`

```srv
sensor_msgs/Image image      # 请求：图片数据
---
int16 number                 # 响应：检测到的人脸数量
float32 use_time             # 响应：处理耗时（秒）
int32[] top                  # 响应：每个人脸的上边界
int32[] right                # 响应：每个人脸的右边界
int32[] bottom               # 响应：每个人脸的下边界
int32[] left                 # 响应：每个人脸的左边界
```

---

## 四、ROS2 C++ 服务端基础框架

### 4.1 最简框架模板

```cpp
#include "rclcpp/rclcpp.hpp"
#include "your_interface/srv/your_service.hpp"  // 服务接口头文件

// 1. 创建节点类，继承自 rclcpp::Node
class MyServiceServer : public rclcpp::Node
{
private:
    // 2. 声明服务对象
    rclcpp::Service<your_interface::srv::YourService>::SharedPtr service_;

public:
    explicit MyServiceServer(const std::string &node_name) : Node(node_name)
    {
        // 3. 创建服务，绑定回调函数
        service_ = this->create_service<your_interface::srv::YourService>(
            "service_name",  // 服务名称
            std::bind(&MyServiceServer::service_callback,
                      this,
                      std::placeholders::_1,   // request
                      std::placeholders::_2)); // response

        RCLCPP_INFO(get_logger(), "服务已启动");
    }

    // 4. 服务回调函数
    void service_callback(
        const your_interface::srv::YourService::Request::SharedPtr request,
        your_interface::srv::YourService::Response::SharedPtr response)
    {
        // 处理请求，填充响应
        // request->xxx 获取请求数据
        // response->xxx 设置响应数据
    }
};

// 5. 主函数
int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);                              // 初始化ROS2
    auto node = std::make_shared<MyServiceServer>("node_name");
    rclcpp::spin(node);                                    // 保持节点运行
    rclcpp::shutdown();                                    // 关闭ROS2
    return 0;
}
```

### 4.2 关键步骤说明

| 步骤 | 说明 |
|------|------|
| 继承 `rclcpp::Node` | 所有ROS2节点都要继承这个基类 |
| `create_service<T>()` | 创建服务，T是服务类型 |
| `std::bind()` | 绑定回调函数，_1和_2是request和response的占位符 |
| `rclcpp::spin()` | 让节点保持运行，等待并处理请求 |

---

## 五、人脸检测服务端完整代码

文件：`src/demo_cpp_service/src/face_detect_server.cpp`

```cpp
#include "chapt4_interface/srv/face_detector.hpp"
#include "cv_bridge/cv_bridge.h"
#include "opencv2/opencv.hpp"
#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/image.hpp"

class FaceDetectServer : public rclcpp::Node
{
private:
    // 服务对象
    rclcpp::Service<chapt4_interface::srv::FaceDetector>::SharedPtr service_;
    // OpenCV人脸检测器
    cv::CascadeClassifier face_cascade_;

public:
    explicit FaceDetectServer(const std::string &node_name) : Node(node_name)
    {
        // 创建服务
        service_ = this->create_service<chapt4_interface::srv::FaceDetector>(
            "face_detect",
            std::bind(&FaceDetectServer::detect_callback,
                      this,
                      std::placeholders::_1,
                      std::placeholders::_2));

        // 加载人脸检测模型
        if (!face_cascade_.load("/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml"))
        {
            RCLCPP_ERROR(get_logger(), "无法加载人脸检测模型！");
        }

        RCLCPP_INFO(get_logger(), "人脸检测服务已启动，等待请求...");
    }

    // 服务回调函数
    void detect_callback(const chapt4_interface::srv::FaceDetector::Request::SharedPtr request,
                         chapt4_interface::srv::FaceDetector::Response::SharedPtr response)
    {
        // 记录开始时间
        auto start_time = this->now();

        // cv_bridge: 将ROS图像消息转换为OpenCV格式
        cv::Mat image = cv_bridge::toCvCopy(request->image, "bgr8")->image;

        // 转灰度图
        cv::Mat gray;
        cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);

        // 人脸检测
        std::vector<cv::Rect> faces;
        face_cascade_.detectMultiScale(gray, faces, 1.1, 15, 0, cv::Size(80, 80));

        // 填充响应
        response->number = faces.size();

        for (const auto &face : faces)
        {
            response->top.push_back(face.y);
            response->bottom.push_back(face.y + face.height);
            response->left.push_back(face.x);
            response->right.push_back(face.x + face.width);
        }

        // 计算耗时
        auto end_time = this->now();
        response->use_time = (end_time - start_time).seconds();

        RCLCPP_INFO(get_logger(), "检测到%d张人脸,耗时%.3f秒", response->number, response->use_time);
    }
};

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<FaceDetectServer>("face_detect_server");
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

---

## 六、CMakeLists.txt 配置

```cmake
# 添加可执行文件
add_executable(face_detect_server src/face_detect_server.cpp)

# 链接依赖
ament_target_dependencies(face_detect_server
  rclcpp
  OpenCV
  sensor_msgs
  chapt4_interface
  cv_bridge
)

# 安装
install(TARGETS face_detect_server
  DESTINATION lib/${PROJECT_NAME}
)
```

---

## 七、运行与测试

### 编译
```bash
cd ~/ros2_chapt4/chapt4_ws
colcon build --packages-select demo_cpp_service
source install/setup.bash
```

### 运行服务端
```bash
ros2 run demo_cpp_service face_detect_server
```

### 查看服务是否启动
```bash
ros2 service list
# 应该能看到 /face_detect
```

---

## 八、注意事项

1. **sensor_msgs/Image 无法用命令行直接发送**
   - Image 消息包含大量像素数据，命令行无法方便构造
   - 需要编写客户端代码来发送图片

2. **异常处理建议**
   - 生产环境中应添加 try-catch 防止空图片等异常导致崩溃

3. **cv_bridge 的作用**
   - ROS 使用 `sensor_msgs/Image`
   - OpenCV 使用 `cv::Mat`
   - cv_bridge 负责两者之间的转换

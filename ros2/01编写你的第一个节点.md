# 01 编写你的第一个节点

> 本笔记涵盖：C++基础 → 编译方法 → ROS2节点开发

---

# 第一部分：C++ 基础知识

## 1.1 main 函数参数详解

C/C++ 的 `main` 函数可以接收命令行参数：

```cpp
int main(int argc, const char** argv)
```

### 参数说明

| 参数 | 含义 | 说明 |
|------|------|------|
| `int argc` | argument count | 命令行参数的**数量**（包括程序本身） |
| `const char** argv` | argument vector | 命令行参数的**字符串数组** |

### 示例

```cpp
#include <iostream>

int main(int argc, const char** argv)
{
    std::cout << "参数数量=" << argc << std::endl;
    std::cout << "程序名字=" << argv[0] << std::endl;
    return 0;
}
```

运行 `./a.out hello world` 时：
- `argc` = 3
- `argv[0]` = `"./a.out"`（程序名）
- `argv[1]` = `"hello"`
- `argv[2]` = `"world"`

---

## 1.2 字符串比较的正确方式

### 常见错误

```cpp
if (argv[1] == "world")  // 错误！比较的是内存地址
```

| 表达式 | 类型 | 实际比较的是 |
|--------|------|--------------|
| `argv[1]` | `const char*` | 内存地址 |
| `"world"` | `const char*` | 内存地址 |

### 正确写法

**方法1：C风格 - strcmp()**
```cpp
#include <cstring>
if (strcmp(argv[1], "world") == 0)  // 返回0表示相等
```

**方法2：C++风格 - std::string**
```cpp
#include <string>
if (std::string(argv[1]) == "world")  // 可以直接用 ==
```

### 为什么 std::string 可以用 `==`？

**答案：运算符重载（Operator Overloading）**

`std::string` 类重载了 `==` 运算符，使其比较字符串内容而非地址：

| 类型 | `==` 比较的是 | 原因 |
|------|---------------|------|
| `const char*` | 内存地址 | 原始指针，没有重载 |
| `std::string` | 字符串内容 | 类重载了 `==` 运算符 |

---

# 第二部分：编译方法

## 2.1 使用 g++ 直接编译

### 基本用法

```bash
# 方法1：指定输出文件名
g++ ros2_cpp_node.cpp -o my_program

# 方法2：使用默认名 a.out
g++ ros2_cpp_node.cpp
```

### 常用编译选项

| 选项 | 说明 |
|------|------|
| `-o <文件名>` | 指定输出文件名 |
| `-g` | 生成调试信息 |
| `-Wall` | 开启所有警告 |
| `-std=c++17` | 指定C++标准版本 |

### 完整示例

```bash
g++ -std=c++17 -Wall -g ros2_cpp_node.cpp -o my_node
./my_node
```

---

## 2.2 使用 CMake 编译（推荐）

### CMakeLists.txt 完整示例

```cmake
cmake_minimum_required(VERSION 3.8)
project(ros2_cpp)

# 创建可执行文件
add_executable(ros2_cpp_node ros2_cpp_node.cpp)

# 查找 rclcpp 库
find_package(rclcpp REQUIRED)

# 添加头文件路径
target_include_directories(ros2_cpp_node PUBLIC ${rclcpp_INCLUDE_DIRS})

# 链接库
target_link_libraries(ros2_cpp_node ${rclcpp_LIBRARIES})
```

### 逐行解释

| 代码 | 作用 |
|------|------|
| `cmake_minimum_required(VERSION 3.8)` | 指定 CMake 最低版本 |
| `project(ros2_cpp)` | 定义项目名称 |
| `add_executable(ros2_cpp_node ros2_cpp_node.cpp)` | 创建可执行文件 |
| `find_package(rclcpp REQUIRED)` | 查找 rclcpp 库 |
| `target_include_directories(...)` | 添加头文件搜索路径 |
| `target_link_libraries(...)` | 链接库文件 |

### 哪些名字是自定义的？

```cmake
project(ros2_cpp)
        ↑ 自定义：项目名称，可以改成任意名字

add_executable(ros2_cpp_node ros2_cpp_node.cpp)
               ↑ 自定义        ↑ 必须是真实存在的文件名！
               可执行文件名
```

| 名字 | 是否自定义 | 说明 |
|------|------------|------|
| `ros2_cpp` | ✅ 自定义 | 项目名，可改成 `my_robot` 等 |
| `ros2_cpp_node` | ✅ 自定义 | 可执行文件名，可改成 `hello_node` 等 |
| `ros2_cpp_node.cpp` | ❌ 不能随意改 | 必须是实际存在的源文件名 |

### 编译和运行步骤

```bash
# 1. 加载 ROS2 环境（重要！）
source /opt/ros/humble/setup.bash

# 2. 创建并进入 build 目录
mkdir -p build && cd build

# 3. 运行 CMake 配置
cmake ..

# 4. 编译
make

# 5. 运行节点
./ros2_cpp_node
```

### 编译流程图

```
┌─────────────────────┐
│  source ROS2 环境    │  ← 让系统找到 rclcpp
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│  mkdir build && cd  │  ← 创建构建目录
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│  cmake ..           │  ← 生成 Makefile
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│  make               │  ← 编译生成可执行文件
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│  ./ros2_cpp_node    │  ← 运行节点
└─────────────────────┘
```

### 常见问题

**Q: 为什么要 source ROS2 环境？**

`find_package(rclcpp REQUIRED)` 需要知道 rclcpp 在哪里。执行 `source` 后，系统会设置环境变量，让 CMake 能够找到 ROS2 的库和头文件。

**Q: 为什么要创建 build 目录？**

这叫做**外部构建（out-of-source build）**：
- 保持源代码目录干净
- 方便清理（直接删除 build 目录即可）
- 可以创建多个构建配置

---

# 第三部分：ROS2 节点开发

## 3.1 最简单的 ROS2 节点

```cpp
#include <rclcpp/rclcpp.hpp>

int main(int argc, const char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<rclcpp::Node>("cpp_node");
    RCLCPP_INFO(node->get_logger(), "你好世界");
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

## 3.2 逐行解释

### `rclcpp::init(argc, argv)`

**初始化 ROS2**
- 启动 ROS2 通信系统
- 把命令行参数传给 ROS2
- **必须最先调用**

---

### `auto node = std::make_shared<rclcpp::Node>("cpp_node")`

**创建节点**
- `rclcpp::Node` = ROS2 节点类
- `"cpp_node"` = 节点名字（ROS2 网络中的身份标识）
- `std::make_shared` = 创建智能指针（自动管理内存）

类比：**节点就像网络中的一台电脑**，有自己的名字，可以发送/接收消息

---

### `RCLCPP_INFO(node->get_logger(), "你好世界")`

**打印日志**
- `RCLCPP_INFO` = ROS2 的日志宏（INFO级别）
- `node->get_logger()` = 获取节点的日志器

日志级别：`DEBUG` < `INFO` < `WARN` < `ERROR` < `FATAL`

---

### `rclcpp::spin(node)`

**保持节点运行**
- 让节点进入"循环等待"状态
- 持续监听和处理消息、服务、定时器等回调
- **程序会停在这里**，直到 Ctrl+C

类比：**相当于服务员一直站着等待顾客点单**

---

### `rclcpp::shutdown()`

**关闭 ROS2**
- 清理资源，断开通信
- **必须最后调用**

---

## 3.3 节点运行流程图

```
┌─────────────────┐
│  rclcpp::init   │  ← 启动ROS2
└────────┬────────┘
         ▼
┌─────────────────┐
│   创建节点       │  ← 注册身份
└────────┬────────┘
         ▼
┌─────────────────┐
│   打印日志       │  ← 输出信息
└────────┬────────┘
         ▼
┌─────────────────┐
│  rclcpp::spin   │  ← 循环等待（阻塞）
└────────┬────────┘
         ▼ (Ctrl+C)
┌─────────────────┐
│ rclcpp::shutdown│  ← 清理退出
└─────────────────┘
```

---

## 3.4 ROS1 与 ROS2 的区别

### 代码写法对比

| 步骤 | ROS1 (roscpp) | ROS2 (rclcpp) |
|------|---------------|---------------|
| 头文件 | `#include <ros/ros.h>` | `#include <rclcpp/rclcpp.hpp>` |
| 初始化 | `ros::init(argc, argv, "节点名")` | `rclcpp::init(argc, argv)` |
| 创建节点 | `ros::NodeHandle nh` | `std::make_shared<rclcpp::Node>("节点名")` |
| 打印日志 | `ROS_INFO("消息")` | `RCLCPP_INFO(node->get_logger(), "消息")` |
| 循环等待 | `ros::spin()` | `rclcpp::spin(node)` |
| 关闭 | 自动 | `rclcpp::shutdown()` |

### 完整代码对比

**ROS1：**
```cpp
#include <ros/ros.h>

int main(int argc, char** argv)
{
    ros::init(argc, argv, "cpp_node");
    ros::NodeHandle nh;
    ROS_INFO("你好世界");
    ros::spin();
    return 0;
}
```

**ROS2：**
```cpp
#include <rclcpp/rclcpp.hpp>

int main(int argc, const char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<rclcpp::Node>("cpp_node");
    RCLCPP_INFO(node->get_logger(), "你好世界");
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

### 核心架构区别

| 特性 | ROS1 | ROS2 |
|------|------|------|
| **Master** | 需要 `roscore` | **不需要**（去中心化） |
| **通信层** | TCPROS/UDPROS | **DDS**（工业标准） |
| **节点管理** | NodeHandle 句柄 | **智能指针** |
| **多节点** | 一个进程一个节点 | 一个进程**多个节点** |
| **实时性** | 不支持 | 支持 |

### 最重要的区别

```
ROS1:  节点 ──→ Master(roscore) ──→ 节点
       （必须有中心调度）

ROS2:  节点 ←──→ DDS ←──→ 节点
       （去中心化，自动发现）
```

**ROS2 不需要先启动 roscore！** 节点可以直接运行，自动发现彼此。

---

# 快速参考

## 编译运行速查

```bash
# 一键编译运行
source /opt/ros/humble/setup.bash && \
mkdir -p build && cd build && \
cmake .. && make && \
./ros2_cpp_node
```

## 目录结构

```
项目目录/
├── CMakeLists.txt      # CMake 配置文件
├── ros2_cpp_node.cpp   # 源代码
└── build/              # 编译输出目录（自动生成）
    └── ros2_cpp_node   # 可执行文件
```

# 04 C++新特性

## 目录

- [04 C++新特性](#04-c新特性)
  - [目录](#目录)
  - [1. main 函数参数](#1-main-函数参数)
    - [1.1 参数说明](#11-参数说明)
    - [1.2 未使用参数的警告](#12-未使用参数的警告)
    - [1.3 使用场景](#13-使用场景)
  - [2. auto 关键字](#2-auto-关键字)
    - [2.1 基本功能](#21-基本功能)
    - [2.2 基本类型推导](#22-基本类型推导)
    - [2.3 ROS2 中的应用](#23-ros2-中的应用)
    - [2.4 等价写法对比](#24-等价写法对比)
    - [2.5 为什么用智能指针？](#25-为什么用智能指针)
    - [2.6 推导结果总结](#26-推导结果总结)
  - [3. std::cout 与命令行参数的区别](#3-stdcout-与命令行参数的区别)
  - [4. rclcpp 命名空间与 Node 类](#4-rclcpp-命名空间与-node-类)
    - [4.1 rclcpp::Node 的两个层面](#41-rclcppnode-的两个层面)
    - [4.2 命名空间示例](#42-命名空间示例)
    - [4.3 常见 ROS2 命名空间](#43-常见-ros2-命名空间)
    - [4.4 Node 类的定义位置](#44-node-类的定义位置)
    - [4.5 Node 类的构造函数](#45-node-类的构造函数)
  - [5. std::make\_shared 详解](#5-stdmake_shared-详解)
    - [5.1 语法结构](#51-语法结构)
    - [5.2 更多示例](#52-更多示例)
  - [6. 节点创建的数据流向](#6-节点创建的数据流向)
    - [6.1 代码](#61-代码)
    - [6.2 流程图](#62-流程图)
    - [6.3 分步详解](#63-分步详解)
    - [6.4 等价的手动写法](#64-等价的手动写法)
    - [6.5 内存布局](#65-内存布局)
    - [6.6 总结](#66-总结)
  - [7. std::shared\_ptr 智能指针详解](#7-stdshared_ptr-智能指针详解)
    - [7.1 什么是智能指针？](#71-什么是智能指针)
    - [7.2 头文件](#72-头文件)
    - [7.3 创建 shared\_ptr](#73-创建-shared_ptr)
    - [7.4 常用成员函数](#74-常用成员函数)
    - [7.5 引用计数机制图解](#75-引用计数机制图解)
    - [7.6 实际代码示例与输出](#76-实际代码示例与输出)
    - [7.7 ROS2 中的应用](#77-ros2-中的应用)
    - [7.8 为什么 ROS2 使用 shared\_ptr？](#78-为什么-ros2-使用-shared_ptr)
    - [7.9 shared\_ptr vs unique\_ptr vs weak\_ptr](#79-shared_ptr-vs-unique_ptr-vs-weak_ptr)
  - [8. Lambda 表达式](#8-lambda-表达式)
    - [8.1 什么是 Lambda？](#81-什么是-lambda)
    - [8.2 基本语法](#82-基本语法)
    - [8.3 捕获方式详解](#83-捕获方式详解)
    - [8.4 值捕获 vs 引用捕获](#84-值捕获-vs-引用捕获)
    - [8.5 代码示例分析](#85-代码示例分析)
    - [8.6 ROS2 中的 Lambda 应用](#86-ros2-中的-lambda-应用)
      - [定时器回调](#定时器回调)
      - [订阅者回调](#订阅者回调)
    - [8.7 为什么 ROS2 大量使用 Lambda？](#87-为什么-ros2-大量使用-lambda)
    - [8.8 类中使用 Lambda（常见模式）](#88-类中使用-lambda常见模式)
    - [8.9 Lambda vs 普通函数 vs std::bind](#89-lambda-vs-普通函数-vs-stdbind)

---

## 1. main 函数参数

### 1.1 参数说明

```cpp
int main(int argc, char const *argv[])
```

| 参数 | 含义 |
|------|------|
| `argc` | 参数数量（argument count） |
| `argv` | 参数值数组（argument vector） |

### 1.2 未使用参数的警告

如果声明了 `argc` 和 `argv` 但没有使用，编译器会发出警告：

```
warning: unused parameter 'argc' [-Wunused-parameter]
warning: unused parameter 'argv' [-Wunused-parameter]
```

**解决方法：**

方法 1：简化 main 签名（推荐，如果不需要命令行参数）
```cpp
int main()
{
    // ...
}
```

方法 2：保留参数但标记为未使用
```cpp
int main(int /*argc*/, char const* /*argv*/[])
{
    // ...
}
```

### 1.3 使用场景

当程序需要**处理命令行参数**时使用：

```cpp
#include <iostream>

int main(int argc, char const *argv[])
{
    // 检查参数数量
    if (argc < 2) {
        std::cout << "用法: " << argv[0] << " <文件名>" << std::endl;
        return 1;
    }

    // 获取传入的参数
    std::cout << "程序名: " << argv[0] << std::endl;
    std::cout << "第一个参数: " << argv[1] << std::endl;

    return 0;
}
```

运行示例：
```bash
./my_program input.txt
# argv[0] = "./my_program"
# argv[1] = "input.txt"
# argc = 2
```

**常见用途：**
- 指定输入/输出文件路径
- 传递配置选项（如 `-v` 表示详细模式）
- 指定 ROS2 节点名称、话题名称等
- 调试时传递测试数据

---

## 2. auto 关键字

### 2.1 基本功能

`auto` 让编译器根据右侧表达式**自动推断变量类型**。

### 2.2 基本类型推导

```cpp
auto x = 10;      // 推导为 int
auto y = 1.77;    // 推导为 double
auto z = 'G';     // 推导为 char
```

### 2.3 ROS2 中的应用

```cpp
auto node = std::make_shared<rclcpp::Node>("cpp_node");
```

这里 `auto` 推导的类型是：

```cpp
std::shared_ptr<rclcpp::Node>
```

即：**指向 `rclcpp::Node` 的智能指针**

### 2.4 等价写法对比

```cpp
// 使用 auto（简洁）
auto node = std::make_shared<rclcpp::Node>("cpp_node");

// 不使用 auto（冗长）
std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>("cpp_node");
```

### 2.5 为什么用智能指针？

| 特性 | 说明 |
|------|------|
| 自动内存管理 | 当 `node` 不再被使用时，自动释放内存 |
| 引用计数 | 可以安全地在多处共享同一个节点 |
| ROS2 要求 | `rclcpp::spin()` 等函数需要 `shared_ptr` 类型 |

### 2.6 推导结果总结

| 场景 | `auto` 推导结果 |
|------|----------------|
| `auto x = 10;` | `int` |
| `auto y = 1.77;` | `double` |
| `auto z = 'G';` | `char` |
| `auto node = std::make_shared<rclcpp::Node>(...)` | `std::shared_ptr<rclcpp::Node>` |

---

## 3. std::cout 与命令行参数的区别

| | `argc`/`argv` | `std::cout` |
|---|---|---|
| 方向 | **输入** - 从命令行传入程序 | **输出** - 从程序打印到终端 |
| 时机 | 程序启动时 | 程序运行中 |
| 用途 | 接收用户传入的参数 | 显示结果给用户看 |

**形象比喻：**
- `argv`：你在运行程序时**告诉程序**的话（输入）
- `std::cout`：程序运行后**告诉你**的话（输出）

---

## 4. rclcpp 命名空间与 Node 类

### 4.1 rclcpp::Node 的两个层面

| 层面 | `rclcpp` | `Node` |
|------|----------|--------|
| **ROS2 层面** | 功能包（package） | 功能包提供的类 |
| **C++ 层面** | 命名空间（namespace） | 命名空间中的类 |

### 4.2 命名空间示例

```cpp
// :: 是作用域解析符
rclcpp::Node        // rclcpp 命名空间下的 Node 类
rclcpp::spin()      // rclcpp 命名空间下的 spin 函数
std::cout           // std 命名空间下的 cout 对象
std::shared_ptr     // std 命名空间下的 shared_ptr 类
```

### 4.3 常见 ROS2 命名空间

| ROS2 功能包 | C++ 命名空间 | 类/函数 |
|-------------|--------------|---------|
| `rclcpp` | `rclcpp::` | `Node`, `spin()` |
| `std_msgs` | `std_msgs::msg::` | `String`, `Int32` |
| 标准库 | `std::` | `cout`, `vector`, `string` |

### 4.4 Node 类的定义位置

```
/opt/ros/humble/include/rclcpp/rclcpp/node.hpp
```

### 4.5 Node 类的构造函数

```cpp
// 构造函数 1：只传节点名
explicit Node(
    const std::string & node_name,
    const NodeOptions & options = NodeOptions());

// 构造函数 2：传节点名 + 命名空间
explicit Node(
    const std::string & node_name,
    const std::string & namespace_,
    const NodeOptions & options = NodeOptions());
```

---

## 5. std::make_shared 详解

### 5.1 语法结构

```cpp
std::make_shared<类型>(构造函数参数...)
```

| 部分 | 作用 |
|------|------|
| `<rclcpp::Node>` | 指定**创建什么类型**的对象 |
| `("cpp_node")` | 传给该类型**构造函数的参数** |

### 5.2 更多示例

```cpp
// 创建 Node，传入节点名 "cpp_node"
auto node = std::make_shared<rclcpp::Node>("cpp_node");

// 创建 string，传入内容 "hello"
auto str = std::make_shared<std::string>("hello");

// 创建 vector<int>，传入初始大小 10
auto vec = std::make_shared<std::vector<int>>(10);
```

---

## 6. 节点创建的数据流向

### 6.1 代码

```cpp
auto node = std::make_shared<rclcpp::Node>("cpp_node");
```

### 6.2 流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                         代码执行流程                              │
└─────────────────────────────────────────────────────────────────┘

  "cpp_node"                    字符串字面量（节点名）
      │
      ▼
┌─────────────────────┐
│ std::make_shared<>  │         ① 接收模板参数 <rclcpp::Node>
│                     │            和构造参数 ("cpp_node")
└─────────────────────┘
      │
      ▼
┌─────────────────────┐
│   分配内存空间       │         ② 在堆上分配足够存放 Node 对象的内存
└─────────────────────┘
      │
      ▼
┌─────────────────────┐
│ rclcpp::Node 构造函数│         ③ 调用 Node("cpp_node")
│                     │            初始化节点名称、日志器等
└─────────────────────┘
      │
      ▼
┌─────────────────────┐
│ shared_ptr 包装     │         ④ 将原始指针包装成智能指针
└─────────────────────┘
      │
      ▼
┌─────────────────────┐
│ auto node = ...     │         ⑤ auto 推导为 shared_ptr<Node>
│                     │            node 变量保存智能指针
└─────────────────────┘
```

### 6.3 分步详解

| 步骤 | 发生了什么 | 谁传给谁 |
|------|-----------|---------|
| ① | 调用 `make_shared` | `"cpp_node"` → `make_shared` 函数 |
| ② | 分配内存 | `make_shared` 在堆上申请内存 |
| ③ | 构造对象 | `"cpp_node"` → `Node` 构造函数的 `node_name` 参数 |
| ④ | 包装指针 | 原始指针 → `shared_ptr` 智能指针 |
| ⑤ | 赋值 | `shared_ptr<Node>` → `node` 变量 |

### 6.4 等价的手动写法

```cpp
// make_shared 一步完成的事情，手动要这样写：

// 步骤 2-3：分配内存 + 调用构造函数
rclcpp::Node* raw_ptr = new rclcpp::Node("cpp_node");

// 步骤 4：包装成智能指针
std::shared_ptr<rclcpp::Node> node(raw_ptr);
```

### 6.5 内存布局

```
栈内存 (Stack)                    堆内存 (Heap)
┌──────────────┐                 ┌─────────────────────┐
│    node      │ ───指向───────▶ │   rclcpp::Node 对象  │
│ (shared_ptr) │                 │  - name: "cpp_node" │
│              │                 │  - logger: ...      │
│ 引用计数: 1   │                 │  - 其他成员...       │
└──────────────┘                 └─────────────────────┘
```

### 6.6 总结

```
"cpp_node" ──▶ make_shared ──▶ Node构造函数 ──▶ shared_ptr ──▶ node变量
   参数           工厂函数        创建对象         包装指针       保存结果
```

简单说：**字符串参数传给 make_shared，make_shared 创建 Node 对象并用智能指针包装，最后赋值给 node 变量**。

---

## 7. std::shared_ptr 智能指针详解

### 7.1 什么是智能指针？

智能指针是 C++ 中用于**自动管理内存**的类模板，主要解决以下问题：

| 问题 | 传统指针 | 智能指针 |
|------|----------|----------|
| 内存泄漏 | 忘记 `delete` 导致泄漏 | 自动释放，无需手动 `delete` |
| 悬空指针 | 指向已释放的内存 | 引用计数为 0 时自动释放 |
| 重复释放 | 多次 `delete` 同一内存 | 引用计数机制避免重复释放 |

### 7.2 头文件

```cpp
#include <memory>  // shared_ptr, make_shared 所在的头文件
```

### 7.3 创建 shared_ptr

```cpp
// 方法 1：使用 make_shared（推荐）
auto p1 = std::make_shared<std::string>("This is a str.");

// 方法 2：直接构造
std::shared_ptr<std::string> p2(new std::string("Hello"));
```

### 7.4 常用成员函数

| 函数 | 作用 | 示例 |
|------|------|------|
| `use_count()` | 返回引用计数（有多少个 shared_ptr 共享同一内存） | `p1.use_count()` |
| `get()` | 返回原始指针（裸指针） | `p1.get()` |
| `reset()` | 放弃当前所有权，引用计数减 1 | `p1.reset()` |
| `operator->` | 访问指向对象的成员 | `p1->c_str()` |
| `operator*` | 解引用，获取指向的对象 | `*p1` |

### 7.5 引用计数机制图解

```
┌─────────────────────────────────────────────────────────────────┐
│                     引用计数变化过程                              │
└─────────────────────────────────────────────────────────────────┘

步骤 1: 创建 p1
┌──────┐         ┌─────────────────┐
│  p1  │────────▶│ "This is a str."│
└──────┘         └─────────────────┘
引用计数: 1

步骤 2: p2 = p1 (共享所有权)
┌──────┐
│  p1  │────┐
└──────┘    │    ┌─────────────────┐
            ├───▶│ "This is a str."│
┌──────┐    │    └─────────────────┘
│  p2  │────┘
└──────┘
引用计数: 2 (p1 和 p2 共享)

步骤 3: p1.reset() (p1 放弃所有权)
┌──────┐
│  p1  │────▶ nullptr (空)
└──────┘
                 ┌─────────────────┐
┌──────┐         │ "This is a str."│
│  p2  │────────▶└─────────────────┘
└──────┘
p1 引用计数: 0
p2 引用计数: 1

步骤 4: p2 离开作用域
引用计数变为 0 → 内存自动释放！
```

### 7.6 实际代码示例与输出

```cpp
#include <iostream>
#include <memory>

int main()
{
    // 创建智能指针
    auto p1 = std::make_shared<std::string>("This is a str.");
    std::cout << "p1的引用计数:" << p1.use_count()
              << ",指向的内存地址:" << p1.get() << std::endl;
    // 输出: p1的引用计数:1,指向的内存地址:0x5f7524eccec0

    // 共享所有权
    auto p2 = p1;
    std::cout << "p1的引用计数:" << p1.use_count()
              << ",指向的内存地址:" << p1.get() << std::endl;
    std::cout << "p2的引用计数:" << p2.use_count()
              << ",指向的内存地址:" << p2.get() << std::endl;
    // 输出: p1的引用计数:2, p2的引用计数:2
    // 输出: 两者内存地址相同（指向同一块内存）

    // p1 放弃所有权
    p1.reset();
    std::cout << "p1的引用计数:" << p1.use_count()
              << ",指向的内存地址:" << p1.get() << std::endl;
    std::cout << "p2的引用计数:" << p2.use_count()
              << ",指向的内存地址:" << p2.get() << std::endl;
    // 输出: p1的引用计数:0,指向的内存地址:0 (nullptr)
    // 输出: p2的引用计数:1（只剩 p2 在用）

    // 访问数据
    std::cout << "p2指向的内存地址数据:" << p2->c_str() << std::endl;
    // 输出: p2指向的内存地址数据:This is a str.

    // main 结束时，p2 离开作用域，引用计数变为 0，内存自动释放
}
```

### 7.7 ROS2 中的应用

```cpp
// 创建节点
auto node = std::make_shared<rclcpp::Node>("cpp_node");
// node 类型: std::shared_ptr<rclcpp::Node>
// 引用计数: 1

// 传给 spin 函数
rclcpp::spin(node);
// spin 函数内部也持有 node 的引用
// 引用计数可能增加

// 当程序结束时，所有引用都消失
// 引用计数变为 0，Node 对象自动销毁
```

### 7.8 为什么 ROS2 使用 shared_ptr？

| 原因 | 说明 |
|------|------|
| 多处共享 | 节点可能被多个回调、定时器、订阅者共享 |
| 生命周期管理 | 确保节点在所有使用者完成前不会被销毁 |
| 异步安全 | 回调函数可能在任意时刻执行，shared_ptr 保证安全 |
| API 设计 | `rclcpp::spin()` 等函数接受 `shared_ptr` 类型参数 |

### 7.9 shared_ptr vs unique_ptr vs weak_ptr

| 类型 | 特点 | 使用场景 |
|------|------|----------|
| `shared_ptr` | 共享所有权，引用计数 | 多处共享同一对象 |
| `unique_ptr` | 独占所有权，不可复制 | 单一所有者 |
| `weak_ptr` | 弱引用，不增加计数 | 打破循环引用 |

```cpp
// shared_ptr: 可以复制，共享所有权
auto sp1 = std::make_shared<int>(10);
auto sp2 = sp1;  // OK，引用计数 +1

// unique_ptr: 不可复制，只能移动
auto up1 = std::make_unique<int>(10);
// auto up2 = up1;  // 错误！不可复制
auto up2 = std::move(up1);  // OK，所有权转移
```

---

## 8. Lambda 表达式

### 8.1 什么是 Lambda？

Lambda 表达式是 C++11 引入的**匿名函数**，可以在代码中定义一个临时的、没有名字的函数对象。

**优点：**
- 代码更简洁，无需单独定义函数
- 可以捕获上下文中的变量
- 非常适合作为回调函数

### 8.2 基本语法

```
[捕获列表](参数列表) -> 返回类型 { 函数体 }
```

| 部分 | 说明 | 是否必须 |
|------|------|----------|
| `[捕获列表]` | 指定捕获哪些外部变量 | 必须 |
| `(参数列表)` | 和普通函数参数一样 | 可省略（无参数时） |
| `-> 返回类型` | 指定返回类型 | 可省略（编译器自动推导） |
| `{ 函数体 }` | 函数的具体实现 | 必须 |

### 8.3 捕获方式详解

| 捕获方式 | 含义 | 示例 |
|----------|------|------|
| `[]` | 不捕获任何外部变量 | `[]() { ... }` |
| `[x]` | 值捕获：复制 x 的值 | `[x]() { cout << x; }` |
| `[&x]` | 引用捕获：引用 x，可修改原变量 | `[&x]() { x = 10; }` |
| `[=]` | 值捕获所有外部变量 | `[=]() { ... }` |
| `[&]` | 引用捕获所有外部变量 | `[&]() { ... }` |
| `[this]` | 捕获当前对象指针 | `[this]() { this->func(); }` |
| `[=, &x]` | 默认值捕获，但 x 用引用 | `[=, &x]() { ... }` |

### 8.4 值捕获 vs 引用捕获

```cpp
int x = 10;

// 值捕获：复制 x 的值到 lambda 内部
auto by_value = [x]() {
    // x 是副本，修改不影响外部
    std::cout << x << std::endl;  // 输出 10
};

// 引用捕获：引用外部的 x
auto by_ref = [&x]() {
    x = 20;  // 修改的是外部的 x
};

by_ref();
std::cout << x << std::endl;  // 输出 20（被修改了）
```

### 8.5 代码示例分析

```cpp
// Lambda 1: 带参数，无捕获
auto add = [](int a, int b) -> int
{
    return a + b;
};
// []        : 不捕获外部变量
// (int a, int b) : 两个参数
// -> int    : 返回 int 类型
// 调用: add(200, 100) 返回 300

int sum = add(200, 100);  // sum = 300

// Lambda 2: 无参数，值捕获外部变量
auto print_sum = [sum]() -> void
{
    std::cout << sum << std::endl;
};
// [sum]  : 值捕获 sum（复制 300 进来）
// ()     : 无参数
// -> void: 无返回值
// 调用: print_sum() 输出 300
```

### 8.6 ROS2 中的 Lambda 应用

#### 定时器回调

```cpp
#include "rclcpp/rclcpp.hpp"

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<rclcpp::Node>("timer_demo");

    int count = 0;

    // 使用 lambda 作为定时器回调
    // 每秒执行一次
    auto timer = node->create_wall_timer(
        std::chrono::seconds(1),
        [&count, &node]() {  // 引用捕获 count 和 node
            count++;
            RCLCPP_INFO(node->get_logger(), "计数: %d", count);
        }
    );

    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

#### 订阅者回调

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<rclcpp::Node>("subscriber_demo");

    // 使用 lambda 作为订阅回调
    auto sub = node->create_subscription<std_msgs::msg::String>(
        "topic_name",  // 话题名
        10,            // 队列长度
        [&node](const std_msgs::msg::String::SharedPtr msg) {
            // msg 是收到的消息
            RCLCPP_INFO(node->get_logger(), "收到: %s", msg->data.c_str());
        }
    );

    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

### 8.7 为什么 ROS2 大量使用 Lambda？

| 原因 | 说明 |
|------|------|
| 简洁 | 无需单独定义回调函数，代码更紧凑 |
| 捕获上下文 | 可以直接使用外部变量（如 node、count） |
| 灵活 | 可以在创建订阅/定时器的地方直接定义行为 |
| 类成员 | 在类中使用 `[this]` 可以访问所有成员变量和函数 |

### 8.8 类中使用 Lambda（常见模式）

```cpp
class MyNode : public rclcpp::Node
{
public:
    MyNode() : Node("my_node")
    {
        // 使用 [this] 捕获当前对象
        timer_ = this->create_wall_timer(
            std::chrono::seconds(1),
            [this]() {
                count_++;  // 可以访问成员变量
                RCLCPP_INFO(this->get_logger(), "计数: %d", count_);
            }
        );
    }

private:
    rclcpp::TimerBase::SharedPtr timer_;
    int count_ = 0;
};
```

### 8.9 Lambda vs 普通函数 vs std::bind

| 方式 | 优点 | 缺点 |
|------|------|------|
| Lambda | 简洁、可捕获上下文 | 复杂逻辑时可读性差 |
| 普通函数 | 可复用、易测试 | 需要额外传参 |
| std::bind | 可绑定成员函数 | 语法繁琐 |

```cpp
// 三种方式实现定时器回调

// 1. Lambda（推荐）
auto timer1 = node->create_wall_timer(1s, [this]() { callback(); });

// 2. 普通函数
void my_callback() { ... }
auto timer2 = node->create_wall_timer(1s, my_callback);

// 3. std::bind（绑定成员函数）
auto timer3 = node->create_wall_timer(1s, std::bind(&MyClass::callback, this));
```

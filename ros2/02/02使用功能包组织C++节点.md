# 02 使用功能包组织C++节点

## 一、ROS2 创建功能包命令

### 基本命令
```bash
ros2 pkg create --build-type ament_cmake --license Apache-2.0 demo_cpp_pkg
```

### 参数说明

| 参数 | 含义 |
|------|------|
| `ros2 pkg create` | ROS2 创建功能包的基础命令 |
| `--build-type ament_cmake` | 指定构建类型为 ament_cmake，用于 C++ 项目 |
| `--license Apache-2.0` | 指定开源许可证为 Apache 2.0 |
| `demo_cpp_pkg` | 新建功能包的名称 |

### 生成的目录结构
```
demo_cpp_pkg/
├── CMakeLists.txt      # CMake 构建配置
├── package.xml         # 包的元数据（依赖、描述等）
├── include/            # 头文件目录
│   └── demo_cpp_pkg/
└── src/                # 源代码目录
```

---

## 二、ROS1 vs ROS2 创建功能包对比

### 1. 命令对比

| 项目 | ROS1 | ROS2 |
|------|------|------|
| 创建命令 | `catkin_create_pkg` | `ros2 pkg create` |
| 示例 | `catkin_create_pkg demo std_msgs rospy` | `ros2 pkg create --build-type ament_cmake demo` |

### 2. 构建系统

| 项目 | ROS1 | ROS2 |
|------|------|------|
| 构建系统 | catkin | ament |
| C++ 构建 | catkin (CMake) | ament_cmake |
| Python 构建 | catkin | ament_python |
| 编译命令 | `catkin_make` 或 `catkin build` | `colcon build` |

### 3. 目录结构差异

**ROS1：**
```
catkin_ws/
├── src/
│   └── demo_pkg/
│       ├── CMakeLists.txt
│       ├── package.xml        # format 1 或 2
│       ├── src/
│       └── include/
├── build/
└── devel/
```

**ROS2：**
```
ros2_ws/
├── src/
│   └── demo_pkg/
│       ├── CMakeLists.txt
│       ├── package.xml        # format 3
│       ├── src/
│       └── include/
├── build/
├── install/                   # 直接安装，无 devel
└── log/
```

### 4. package.xml 差异

**ROS1 (format 2)：**
```xml
<package format="2">
  <buildtool_depend>catkin</buildtool_depend>
  <build_depend>roscpp</build_depend>
  <exec_depend>roscpp</exec_depend>
</package>
```

**ROS2 (format 3)：**
```xml
<package format="3">
  <buildtool_depend>ament_cmake</buildtool_depend>
  <depend>rclcpp</depend>
</package>
```

### 5. CMakeLists.txt 差异

| 项目 | ROS1 | ROS2 |
|------|------|------|
| 查找包 | `find_package(catkin REQUIRED)` | `find_package(ament_cmake REQUIRED)` |
| 导出 | `catkin_package()` | `ament_package()` |
| C++ 库 | `roscpp` | `rclcpp` |
| Python 库 | `rospy` | `rclpy` |

### 6. ROS2 主要改进

- **无 devel 空间**：ROS2 直接安装到 `install/`，更接近标准软件安装流程
- **独立运行**：ROS2 不依赖 `roscore`，节点可独立运行
- **更好的 Python 支持**：`ament_python` 提供纯 Python 包支持
- **许可证参数**：ROS2 创建时可直接指定 `--license`

---

## 三、为什么 ROS1 和 ROS2 差别这么大？

### 核心原因

> **ROS2 是完全重写的系统，不是 ROS1 的升级版。**

ROS1 诞生于 2007 年，设计初衷是**学术研究和原型开发**。随着机器人行业发展，暴露出很多问题。ROS2 从 2015 年开始**从零重新设计**，目标是**工业级应用**。

### 主要变化原因

| 问题领域 | ROS1 的问题 | ROS2 的解决方案 |
|---------|------------|----------------|
| **通信层** | 自研的 TCPROS/UDPROS，不够健壮 | 采用 **DDS** 工业通信标准 |
| **架构** | 依赖 roscore 中心节点，单点故障 | **去中心化**，无需 roscore |
| **实时性** | 不支持实时系统 | 支持 **RTOS**，满足实时需求 |
| **跨平台** | 主要支持 Linux | 官方支持 **Windows、macOS、RTOS** |
| **安全性** | 无内置安全机制 | 内置 **SROS2** 安全框架 |
| **构建系统** | catkin 与 CMake 耦合过深 | **ament** 更模块化灵活 |

### 为什么构建系统要换？

**catkin 的问题：**
```
catkin_ws/
├── build/    # 构建产物
├── devel/    # 开发空间（ROS特有概念）
└── src/
```
- `devel/` 空间是 ROS 特有概念，不符合软件安装标准
- Python 包必须和 CMake 混在一起
- 不支持并行构建多个独立包

**ament 的改进：**
```
ros2_ws/
├── build/
├── install/   # 直接安装，标准化
├── log/       # 日志分离
└── src/
```
- 使用 `colcon` 替代 `catkin_make`，支持并行构建
- `ament_python` 支持纯 Python 包，无需 CMake
- 更接近标准软件安装流程

### 一句话总结

> **ROS1 是"实验室产品"，ROS2 是"工业级产品"。**
>
> 就像从 Python 2 到 Python 3，不是简单升级，而是为了解决根本性问题进行的重新设计。这就是为什么命令、文件格式、目录结构都不一样——因为底层架构完全不同了。

---

## 四、ROS2 C++ 功能包完整开发流程

### 第一步：创建工作空间

```bash
# 创建工作空间目录
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws
```

### 第二步：创建功能包

```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_cmake --license Apache-2.0 demo_cpp_pkg
```

生成的目录结构：
```
demo_cpp_pkg/
├── CMakeLists.txt
├── package.xml
├── include/
│   └── demo_cpp_pkg/
└── src/
```

### 第三步：编写 C++ 代码

在 `src/` 目录下创建源文件，例如 `cpp_node.cpp`：

```cpp
#include "rclcpp/rclcpp.hpp"

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<rclcpp::Node>("cpp_node");
    RCLCPP_INFO(node->get_logger(), "Hello ROS2!");
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

### 第四步：配置 CMakeLists.txt（关键！）

```cmake
cmake_minimum_required(VERSION 3.8)
project(demo_cpp_pkg)

# 编译选项
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# 查找依赖
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)

# 添加可执行文件
add_executable(cpp_node src/cpp_node.cpp)

# 链接依赖
ament_target_dependencies(cpp_node rclcpp)

# ⚠️ 关键！安装规则（没有这行 ros2 run 找不到）
install(TARGETS cpp_node
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

### 第五步：编译

```bash
# 回到工作空间根目录
cd ~/ros2_ws

# 编译所有包
colcon build

# 或只编译指定包
colcon build --packages-select demo_cpp_pkg
```

编译后的目录结构：
```
ros2_ws/
├── src/              # 源代码
├── build/            # 编译中间文件
├── install/          # 编译结果（可执行文件在这里）
└── log/              # 编译日志
```

### 第六步：加载环境

```bash
source install/setup.bash
```

### 第七步：运行节点

```bash
ros2 run demo_cpp_pkg cpp_node
```

---

## 五、常见错误排查

| 错误 | 原因 | 解决方案 |
|------|------|---------|
| `No executable found` | CMakeLists.txt 缺少 `install()` | 添加 `install(TARGETS ...)` |
| `Package not found` | 没有 source 环境 | 执行 `source install/setup.bash` |
| `rclcpp not found` | 没有 source ROS2 环境 | 执行 `source /opt/ros/humble/setup.bash` |

---

## 六、两种编译方式对比

| 方式 | 传统 CMake | ROS2 标准（colcon） |
|------|-----------|-------------------|
| 命令 | `mkdir build && cd build && cmake .. && make` | `colcon build` |
| 执行位置 | 功能包内部 | 工作空间根目录 |
| 产物位置 | `build/可执行文件` | `install/包名/lib/包名/可执行文件` |
| 运行方式 | `./cpp_node` | `ros2 run 包名 节点名` |
| ROS2集成 | ❌ 无法被 ros2 命令管理 | ✅ 完全集成 |

> **注意**：虽然传统 CMake 方式可以编译，但无法使用 `ros2 run` 运行，必须使用 `colcon build` 才能让 ROS2 系统正确管理节点。

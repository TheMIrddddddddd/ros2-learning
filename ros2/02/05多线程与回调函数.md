# C++ 多线程与回调函数

## 目录

- [C++ 多线程与回调函数](#c-多线程与回调函数)
  - [目录](#目录)
  - [1. 函数包装器 std::function](#1-函数包装器-stdfunction)
    - [1.1 什么是 std::function](#11-什么是-stdfunction)
    - [1.2 可以存储的类型](#12-可以存储的类型)
    - [1.3 支持的参数类型](#13-支持的参数类型)
  - [2. 回调函数的概念](#2-回调函数的概念)
    - [2.1 为什么需要回调](#21-为什么需要回调)
    - [2.2 回调的工作流程](#22-回调的工作流程)
  - [3. 复杂类型声明解析](#3-复杂类型声明解析)
    - [3.1 逐层拆解](#31-逐层拆解)
    - [3.2 盒子比喻](#32-盒子比喻)
    - [3.3 类型签名 vs 函数实现](#33-类型签名-vs-函数实现)
  - [4. 使用流程](#4-使用流程)
    - [4.1 理解验证](#41-理解验证)
  - [5. 完整代码示例](#5-完整代码示例)
    - [5.1 DownLoad 类定义](#51-download-类定义)
    - [5.2 调用示例](#52-调用示例)
  - [6. 深入理解：数据流与调用关系](#6-深入理解数据流与调用关系)
    - [6.1 类与对象](#61-类与对象)
    - [6.2 函数参数 = 接收槽位](#62-函数参数--接收槽位)
    - [6.3 回调函数的数据来源（重点！）](#63-回调函数的数据来源重点)
  - [总结](#总结)

---

## 1. 函数包装器 std::function

### 1.1 什么是 std::function

**核心作用：把"函数"当作"变量"来传递**

没有 `std::function` 之前，函数就是函数，不能像普通变量一样传来传去。有了它，函数可以：
- 存到变量里
- 作为参数传给另一个函数
- 放到容器（如 vector）里

### 1.2 可以存储的类型

| 可存储类型 | 示例 |
|-----------|------|
| 普通函数 | `void foo(const string&, const string&)` |
| Lambda 表达式 | `[](const string& a, const string& b) { ... }` |
| 函数对象 | 重载了 `operator()` 的类 |
| 成员函数 | 通过 `std::bind` 绑定 |

### 1.3 支持的参数类型

`std::function` 的参数类型可以是**任何 C++ 类型**，不只是 `std::string`：

| 类型 | 示例 |
|------|------|
| 基本类型 | `int`, `double`, `float`, `char`, `bool` |
| 字符串 | `std::string` |
| 容器 | `std::vector<int>`, `std::map<string, int>` |
| 指针 | `int*`, `char*` |
| 自定义类 | `MyClass`, `Person`, `Node` |
| 智能指针 | `std::shared_ptr<T>` |
| 无参数 | `void()` |

**代码示例：**

```cpp
// 传入两个 int
std::function<void(int, int)> f1;
f1 = [](int a, int b) { std::cout << a + b; };
f1(10, 20);  // 输出 30

// 传入 double 返回 double
std::function<double(double, double)> f2;
f2 = [](double x, double y) { return x * y; };
double result = f2(3.14, 2.0);  // 结果 6.28

// 无参数无返回值
std::function<void()> f3;
f3 = []() { std::cout << "Hello"; };
f3();  // 输出 Hello

// 传入 vector
std::function<int(std::vector<int>&)> f4;
f4 = [](std::vector<int>& v) { return v.size(); };

// 传入自定义类
std::function<void(Person&)> f5;
f5 = [](Person& p) { std::cout << p.name; };
```

---

## 2. 回调函数的概念

### 2.1 为什么需要回调

在异步编程中，某些操作（如网络下载）不会立即完成。回调函数允许我们：
1. 发起操作后继续执行其他代码
2. 操作完成时自动通知调用者
3. 在通知时传递结果数据

### 2.2 回调的工作流程

```
调用 download() 发起下载
        │
        ▼
   下载在后台进行...
        │
        ▼
   下载完成
        │
        ▼
自动调用 callback 函数，传入结果
```

---

## 3. 复杂类型声明解析

### 3.1 逐层拆解

以下面的声明为例：

```cpp
const std::function<void(const std::string&, const std::string&)> &callback_word_count
```

**从内到外拆解：**

| 层级 | 代码部分 | 含义 |
|------|---------|------|
| 最内层 | `void(const std::string&, const std::string&)` | 函数签名：无返回值，接受两个字符串参数 |
| 中间层 | `std::function<...>` | 函数包装器，能装符合签名的任何可调用对象 |
| 外层 | `const ... &` | const 引用传递，避免拷贝 |
| 最外层 | `callback_word_count` | 参数名 |

**图示：**

```
const std::function<void(const std::string&, const std::string&)> &callback_word_count
│     │              │    │                                        │
│     │              │    └── 这个函数需要两个 string 参数           │
│     │              └── 这个函数不返回任何值                        │
│     └── 这是一个可调用对象的包装器                                  │
│                                                                   │
└── 以 const 引用方式传递，参数名叫 callback_word_count
```

### 3.2 盒子比喻

可以把 `std::function` 想象成一个**能装函数的盒子**：

| 比喻 | 含义 |
|------|------|
| `std::function` | 一个能装函数的盒子 |
| `<...>` 里的内容 | 盒子的形状规格（能装什么样的函数） |
| `void` | 函数不返回东西 |
| `(const std::string&, const std::string&)` | 函数需要两个字符串参数 |

**类比普通变量：**

```cpp
// 普通变量
int x = 10;              // x 是一个装 int 的盒子

// 函数包装器
std::function<void()> f; // f 是一个装"无参数无返回值函数"的盒子

std::function<int(int, int)> g;  // g 是一个装"接收两个int、返回int"的函数的盒子

std::function<void(const std::string&, const std::string&)> h;
// h 是一个装"接收两个string、无返回值"的函数的盒子
```

### 3.3 类型签名 vs 函数实现

为什么有时候只写 `&` 没有变量名，有时候又有变量名？

**对比：**

| 位置 | 代码 | 作用 |
|------|------|------|
| 类型签名 | `void(const std::string&, const std::string&)` | 只描述"形状"，不需要名字 |
| 函数实现 | `const std::string& a, const std::string& b` | 需要名字，用来在函数体内使用 |

**比喻：**

- **类型签名** = 招聘启事："需要一个会英语的人，一个会日语的人"（不需要知道具体叫什么）
- **函数实现** = 实际雇佣："张三会英语，李四会日语"（需要名字来指挥干活）

**代码对应：**

```cpp
// 类型签名：只说"需要两个 string"
std::function<void(const std::string&, const std::string&)>
//                      ↑ 只有类型          ↑ 只有类型

// 函数实现：给参数起名字，方便在函数体里用
[](const std::string& a, const std::string& b) {
//                    ↑ 有名字       ↑ 有名字
    std::cout << a << b;  // ← 这里要用 a 和 b
}
```

**补充说明：** 类型签名里其实也可以写名字，但会被忽略：

```cpp
// 这两种写法等价：
std::function<void(const std::string&, const std::string&)>      // 省略名字
std::function<void(const std::string& a, const std::string& b)>  // 写上名字（被忽略）
```

---

## 4. 使用流程

```
第1步：定义 callback（空盒子）
    │
    ▼
第2步：往 callback 里放一个函数（Lambda/普通函数）
    │
    ▼
第3步：调用 callback("字符串1", "字符串2")
    │
    ▼
第4步：执行盒子里那个函数的代码
```

**代码示例：**

```cpp
// 1. 定义 callback
std::function<void(const std::string&, const std::string&)> callback;

// 2. 放入一个函数
callback = [](const std::string& a, const std::string& b) {
    std::cout << "收到: " << a << " 和 " << b << std::endl;
};

// 3. 触发/调用
callback("你好", "世界");

// 执行结果：打印 "收到: 你好 和 世界"
```

### 4.1 理解验证

**核心理解：**

```
callback_word_count 作为参数传入 download 函数
        │
        ▼
调用 callback_word_count("你好", "世界")
        │
        ▼
执行函数体里的代码（比如打印 a + b）
```

**关键点澄清：**

`a` 和 `b` 不是"定义变量"，而是**接收参数**：

```cpp
// 传入的 Lambda
[](const std::string& a, const std::string& b) {
    std::cout << a << b << std::endl;
}

// 当调用 callback_word_count("你好", "世界") 时：
// a 接收 "你好"
// b 接收 "世界"
// 输出：你好世界
```

**完整调用链：**

```cpp
// 1. 调用 download，传入回调函数
download("host", "/path", [](const std::string& a, const std::string& b) {
    std::cout << a << b << std::endl;
});

// 2. download 内部执行回调
void download(..., callback_word_count) {
    // 做一些事情...
    callback_word_count("你好", "世界");  // → 输出：你好世界
}
```

---

## 5. 完整代码示例

### 5.1 DownLoad 类定义

```cpp
#include <string>
#include <functional>
#include <iostream>

class DownLoad
{
private:
    /* data */
public:
    void download(
        const std::string &host,
        const std::string &path,
        const std::function<void(const std::string&, const std::string&)> &callback_word_count
    )
    {
        // 模拟下载逻辑
        std::string content = "下载的内容...";
        std::string word_count = "字数统计: 100";

        // 下载完成后，调用回调函数通知调用者
        callback_word_count(content, word_count);
    }
};
```

### 5.2 调用示例

**方式1：使用 Lambda 表达式**

```cpp
DownLoad downloader;
downloader.download("example.com", "/data.txt",
    [](const std::string& content, const std::string& stats) {
        std::cout << "内容: " << content << std::endl;
        std::cout << "统计: " << stats << std::endl;
    }
);
```

**方式2：使用普通函数**

```cpp
// 定义回调函数
void my_callback(const std::string& content, const std::string& stats) {
    std::cout << "内容: " << content << std::endl;
    std::cout << "统计: " << stats << std::endl;
}

// 调用
DownLoad downloader;
downloader.download("example.com", "/data.txt", my_callback);
```

---

## 6. 深入理解：数据流与调用关系

### 6.1 类与对象

```cpp
auto d = DownLoad();  // 创建对象
```

| 概念 | 含义 |
|------|------|
| `DownLoad` | 类（设计图纸） |
| `DownLoad()` | 调用构造函数 |
| `d` | 类的实例/对象（根据图纸造出来的实物） |
| `d.start_download()` | 调用对象的成员函数 |

等价写法：
```cpp
DownLoad d;  // 更简洁，效果一样
```

### 6.2 函数参数 = 接收槽位

函数参数声明不是"实现"，而是**定规矩**（定义接收槽位）：

```cpp
void start_download(
    const std::string& host,        // 槽位1：必须传一个字符串
    const std::string& path,        // 槽位2：必须传一个字符串
    const std::function<...>& callback_word_count  // 槽位3：必须传一个函数
)
```

**比喻：快递柜**

```
┌─────────────────────────────────────────────┐
│            start_download 函数               │
│   ┌─────┐  ┌─────┐  ┌──────────────────┐   │
│   │ host │  │ path │  │ callback         │   │
│   │ 格子 │  │ 格子 │  │ 格子             │   │
│   └─────┘  └─────┘  └──────────────────┘   │
│      ↑         ↑              ↑            │
└──────│─────────│──────────────│────────────┘
    你放入     你放入         你放入
  "http://..."  "/novel1"    word_count
```

### 6.3 回调函数的数据来源（重点！）

**核心问题**：`word_count` 里的 `path` 和 `result` 值从哪来？

**答案**：在 `download()` 函数内部调用回调时传入的！

```cpp
void download(..., callback_word_count) {
    auto response = client.Get(path);  // 发起请求
    if (response->status == 200) {
        callback_word_count(path, response->body);  // ← 这里传入真实数据！
    }                    │           │
}                        │           │
                         ▼           ▼
// word_count 接收数据
[](const std::string& path, const std::string& result) {
//          ↑                        ↑
//    "/novel1.txt"             "小说内容..."
    std::cout << path << result.length();
}
```

**数据流完整路径**：

```
download() 获取数据
      │
      ├── path = "/novel1.txt"（从参数传入）
      │
      ├── response->body = "小说内容..."（HTTP 请求获取）
      │
      └── callback_word_count(path, response->body)  // 调用回调
                               │          │
                               ▼          ▼
                           word_count 的 path 和 result
```

**职责分工**：

| 角色 | 职责 |
|------|------|
| `word_count` | 定义"收到数据后做什么"（打印信息） |
| `download()` | 获取数据，调用回调，**把真实数据传进去** |

---

## 总结

| 概念 | 一句话解释 |
|------|-----------|
| `std::function` | 把函数当变量传递的容器 |
| 回调函数 | 操作完成后自动调用的函数 |
| `<void(...)>` | 描述容器能装什么形状的函数 |
| `const &` | 引用传递，避免拷贝开销 |
| 类型签名 | 只描述参数类型，名字可省略 |
| 函数实现 | 必须有参数名，因为函数体里要用 |
| 参数类型 | 可以是任何 C++ 类型，不限于 string |
| 函数参数 | 接收槽位，用来接收外部传入的值 |
| 回调数据来源 | 由调用回调的函数（如 download）传入 |

# ROS2 话题的订阅 - 学习笔记

---

## 1. create_subscription 函数签名

```cpp
template<class MessageT, class CallbackT, ...>
std::shared_ptr<...> rclcpp::Node::create_subscription(
    const std::string &topic_name,                    // 话题名称
    const rclcpp::QoS &qos,                          // QoS 配置（必需！）
    CallbackT &&callback,                            // 回调函数
    const SubscriptionOptions &options = ...,        // 可选参数
    MessageMemoryStrategyT::SharedPtr msg_mem_strat = ...  // 可选参数
);
```

---

## 2. 正确的订阅写法

### ✅ 正确示例

```cpp
subscriber_ = this->create_subscription<turtlesim::msg::Pose>(
    "/turtle1/pose",    // 话题名
    10,                 // QoS 队列深度
    std::bind(&TurtleCtrlNode::subscriber_callback, this, std::placeholders::_1)
);
```

### ❌ 常见错误

```cpp
// 错误1：缺少 QoS 参数
subscriber_ = this->create_subscription<turtlesim::msg::Pose>(
    "/turtle1/pose",
    std::bind(&TurtleCtrlNode::subscriber_callback, this)  // ❌ QoS 去哪了？
);

// 错误2：缺少占位符 _1
subscriber_ = this->create_subscription<turtlesim::msg::Pose>(
    "/turtle1/pose",
    10,
    std::bind(&TurtleCtrlNode::subscriber_callback, this)  // ❌ 少了 _1
);
```

---

## 3. 配套代码要求

### 3.1 回调函数（作为类的成员函数）

```cpp
// ⚠️ 必须放在类的作用域内，不能放在构造函数里面！
void subscriber_callback(const turtlesim::msg::Pose::SharedPtr pose)
{
    // 处理收到的消息
}
```

### 3.2 成员变量声明

```cpp
rclcpp::Subscription<turtlesim::msg::Pose>::SharedPtr subscriber_;
```

### 3.3 头文件

```cpp
#include "turtlesim/msg/pose.hpp"
```

---

## 4. 完整的节点类示例

```cpp
#include "rclcpp/rclcpp.hpp"
#include "turtlesim/msg/pose.hpp"

class TurtleCtrlNode : public rclcpp::Node
{
private:
    rclcpp::Subscription<turtlesim::msg::Pose>::SharedPtr subscriber_;

    // ✅ 回调函数作为类的成员函数
    void subscriber_callback(const turtlesim::msg::Pose::SharedPtr pose)
    {
        RCLCPP_INFO(this->get_logger(), "位置: x=%.2f, y=%.2f", pose->x, pose->y);
    }

public:
    explicit TurtleCtrlNode(const std::string& node_name) : Node(node_name)
    {
        subscriber_ = this->create_subscription<turtlesim::msg::Pose>(
            "/turtle1/pose",
            10,
            std::bind(&TurtleCtrlNode::subscriber_callback, this, std::placeholders::_1)
        );
    }
};
```

---

## 5. std::placeholders::_1 占位符详解

### 5.1 什么是占位符？

`std::bind` 用于"绑定"函数的部分参数，但有些参数现在还不知道，需要等调用时再填入。

`_1` 的意思是：**"这个位置先占着，等第1个参数传进来时放这里"**

### 5.2 占位符对应关系

```cpp
_1  →  调用时的第1个参数
_2  →  调用时的第2个参数
_3  →  调用时的第3个参数
...
```

### 5.3 数据流动过程

```
std::bind(&TurtleCtrlNode::subscriber_callback, this, std::placeholders::_1)
                                                              ↓
                                                     ROS2 传入的消息 (msg)
                                                              ↓
void subscriber_callback(const turtlesim::msg::Pose::SharedPtr pose)
                                                             ↑
                                                    _1 最终变成 pose
```

### 5.4 详细流程图

```
                    std::bind 创建的绑定对象
                    ┌─────────────────────────────────────────┐
                    │  函数: subscriber_callback              │
                    │  对象: this (固定)                       │
                    │  参数: _1 (占位符，等待填入)              │
                    └─────────────────────────────────────────┘
                                      │
                                      ▼
┌──────────────────────────────────────────────────────────────────┐
│  ROS2 收到消息：msg (类型: turtlesim::msg::Pose::SharedPtr)        │
└──────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
                         调用绑定对象，传入 msg
                                      │
                                      ▼
                    ┌─────────────────────────────────────────┐
                    │   _1  ←──────  msg                      │
                    │   把 msg 填入 _1 的位置                   │
                    └─────────────────────────────────────────┘
                                      │
                                      ▼
                    this->subscriber_callback(msg)
                                      │
                                      ▼
┌──────────────────────────────────────────────────────────────────┐
│  void subscriber_callback(const ...::SharedPtr pose)             │
│                                              ↑                   │
│                                           msg 变成了 pose         │
└──────────────────────────────────────────────────────────────────┘
```

---

## 6. 发布者 vs 订阅者：为什么订阅者需要回调？

### 6.1 核心区别

| | 发布者 (Publisher) | 订阅者 (Subscriber) |
|---|---|---|
| **角色** | 主动发送 | 被动接收 |
| **时机** | **你决定**什么时候发 | **不知道**消息什么时候来 |
| **是否需要回调** | ❌ 不需要 | ✅ 需要 |

### 6.2 发布者：主动发送

```cpp
// 你想发就发，主动权在你手上
publisher_->publish(msg);  // "我现在就要发送！"
```

### 6.3 订阅者：被动接收

```cpp
// 消息随时可能来，你不知道是什么时候
// 所以要留一个"当消息来了请叫我"的函数
void subscriber_callback(const turtlesim::msg::Pose::SharedPtr pose)
{
    // "有消息来了！让我处理一下～"
}
```

### 6.4 比喻理解

- **发布者** = 蛋糕店老板
  - 蛋糕做好了，**主动**放到柜台

- **订阅者** = 等蛋糕的顾客
  - 不知道蛋糕什么时候做好
  - 留个**电话号码（回调函数）**
  - 蛋糕好了，店员就**打电话通知**

### 6.5 总结

```
发布：我主动给 → 不需要回调
订阅：等别人给 → 需要回调（告诉系统：消息来了调用这个函数）
```

---

## 7. 常见话题与消息类型对应

| 话题 | 消息类型 |
|------|----------|
| `/turtle1/pose` | `turtlesim::msg::Pose` |
| `/turtle1/cmd_vel` | `geometry_msgs::msg::Twist` |

⚠️ **注意**：订阅话题时，消息类型必须与话题实际发布的类型匹配！

---

## 8. Lambda 表达式替代写法

除了 `std::bind`，也可以使用 lambda 表达式：

```cpp
subscriber_ = this->create_subscription<turtlesim::msg::Pose>(
    "/turtle1/pose",
    10,
    [this](const turtlesim::msg::Pose::SharedPtr msg) {
        // 直接在这里处理消息
        RCLCPP_INFO(this->get_logger(), "x=%.2f, y=%.2f", msg->x, msg->y);
    }
);
```

---

## 9. `publisher_->publish(msg);` 详解

### 9.1 代码拆解

```cpp
publisher_  ->  publish(msg);
    ↓           ↓       ↓
  智能指针    箭头    成员函数(参数)
```

| 部分 | 含义 |
|------|------|
| `publisher_` | 智能指针，**指向** Publisher 对象 |
| `->` | 通过指针访问成员的运算符 |
| `publish()` | Publisher 对象的**成员函数** |
| `msg` | 要发布的消息 |

### 9.2 类型对应

```cpp
// publisher_ 的类型是：
rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;
//                                            ↑
//                                        SharedPtr = 智能指针
```

### 9.3 比喻理解

```
publisher_   =  蛋糕店的地址（指针，告诉你店在哪）
     ↓
    ->       =  "去这家店"
     ↓
publish(msg) =  "把这个蛋糕卖出去"
```

**完整意思**：通过 `publisher_` 这个指针，调用它指向的 Publisher 对象的 `publish` 函数，把 `msg` 发布出去。

---

## 10. 完整的乌龟控制节点示例

```cpp
#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/twist.hpp"
#include "turtlesim/msg/pose.hpp"
#include <cmath>

class TurtleCtrlNode : public rclcpp::Node
{
private:
    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;
    rclcpp::Subscription<turtlesim::msg::Pose>::SharedPtr subscriber_;

    // ✅ 使用 {} 或 = 初始化成员变量
    double target_x_ = 1.0;
    double target_y_ = 1.0;
    double k_ = 1.0;
    double max_speed_ = 3.0;

    void subscriber_callback(const turtlesim::msg::Pose::SharedPtr pose)
    {
        auto current_x = pose->x;
        auto current_y = pose->y;

        // 计算距离
        auto distance = std::sqrt(
            (target_x_ - current_x) * (target_x_ - current_x) +
            (target_y_ - current_y) * (target_y_ - current_y)
        );

        // ✅ 注意是减号，不是逗号！
        auto angle = std::atan2(
            (target_y_ - current_y),
            (target_x_ - current_x)
        ) - pose->theta;

        auto msg = geometry_msgs::msg::Twist();

        if (distance > 0.1) {
            if (fabs(angle) > 0.2) {
                msg.angular.z = fabs(angle);
            } else {
                msg.linear.x = k_ * distance;
            }
        }

        if (msg.linear.x > max_speed_) {
            msg.linear.x = max_speed_;
        }

        // ✅ 记得发布消息！
        publisher_->publish(msg);
    }

public:
    explicit TurtleCtrlNode(const std::string& node_name) : Node(node_name)
    {
        publisher_ = this->create_publisher<geometry_msgs::msg::Twist>(
            "/turtle1/cmd_vel", 10);

        subscriber_ = this->create_subscription<turtlesim::msg::Pose>(
            "/turtle1/pose",
            10,
            std::bind(&TurtleCtrlNode::subscriber_callback, this, std::placeholders::_1)
        );
    }
};

int main(int argc, char const *argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<TurtleCtrlNode>("turtle_ctrl");
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

---

*笔记整理完成 ✨*

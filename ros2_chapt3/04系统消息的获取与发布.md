# 04 系统消息的获取与发布

## 目录

- [1. 自定义消息接口的使用](#1-自定义消息接口的使用)
  - [1.1 头文件路径](#11-头文件路径)
  - [1.2 正确的 include 写法](#12-正确的-include-写法)
  - [1.3 VS Code 配置](#13-vs-code-配置-c_cpp_propertiesjson)
  - [1.4 Publisher 声明](#14-publisher-声明使用自定义消息)
  - [1.5 C++ 冒号符号区别](#15-c-冒号符号区别)
- [2. Python 与 C++ 对照](#2-python-与-c-对照)
- [3. 系统信息获取（C++ 实现）](#3-系统信息获取c-实现)
  - [3.1 消息定义](#31-消息定义-systemstatusmsg)
  - [3.2 C++ 所需头文件](#32-c-所需头文件)
  - [3.3 各字段获取方式](#33-各字段获取方式)
  - [3.4 关键 Linux 文件](#34-关键-linux-文件)
  - [3.5 定时器回调函数绑定](#35-定时器回调函数绑定)
  - [3.6 RCLCPP_INFO 日志打印](#36-rclcpp_info-日志打印)
  - [3.7 CPU 使用率获取](#37-cpu-使用率获取完整实现)
  - [3.8 网络流量获取](#38-网络流量获取完整实现)
  - [3.9 消息字段赋值](#39-消息字段赋值)
- [4. CMake 配置要点](#4-cmake-配置要点)
  - [4.1 package.xml 依赖声明](#41-packagexml-依赖声明)
  - [4.2 CMakeLists.txt 关键配置](#42-cmakeliststxt-关键配置)
- [5. 运行命令](#5-运行命令)
- [6. 常见错误总结](#6-常见错误总结)
- [7. 重要：终端环境配置](#7-重要终端环境配置)
  - [7.1 每个新终端都需要 source](#71-每个新终端都需要-source)
  - [7.2 自动 source（推荐）](#72-自动-source推荐)

---

## 1. 自定义消息接口的使用

### 1.1 头文件路径

ROS2 自定义消息包编译后，头文件生成在 **`install/`** 目录下，而不是 `src/`：

```
install/<包名>/include/<包名>/<包名>/msg/<消息名>.hpp
```

例如：
```
install/status_interface/include/status_interface/status_interface/msg/system_status.hpp
```

### 1.2 正确的 include 写法

```cpp
// 错误 ❌
#include "status_interface/staus_interface.hpp"

// 正确 ✅
#include "status_interface/msg/system_status.hpp"
```

**注意**：
- 消息文件 `SystemStatus.msg` 会生成 `system_status.hpp`（驼峰转下划线）
- 必须包含 `msg/` 子目录

### 1.3 VS Code 配置 (c_cpp_properties.json)

```json
{
  "configurations": [
    {
      "includePath": [
        "${workspaceFolder}/**",
        "/opt/ros/humble/include/**",
        "/home/gan/ros2_chapt3/topic_pra_ws/install/status_interface/include/status_interface/**",
        "/usr/include/**"
      ],
      "name": "ros2",
      "intelliSenseMode": "gcc-x64",
      "compilerPath": "/usr/bin/gcc",
      "cStandard": "gnu11",
      "cppStandard": "c++17"
    }
  ],
  "version": 4
}
```

### 1.4 Publisher 声明（使用自定义消息）

**规律**：`<包名>::msg::<消息名>`

```cpp
// 标准消息的写法
rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;

// 自定义消息的写法
rclcpp::Publisher<status_interface::msg::SystemStatus>::SharedPtr publisher_;
```

| 消息文件 | C++ 类型 |
|---------|---------|
| `geometry_msgs/msg/Twist.msg` | `geometry_msgs::msg::Twist` |
| `status_interface/msg/SystemStatus.msg` | `status_interface::msg::SystemStatus` |

**重要：必须使用 `::SharedPtr`**

```cpp
// 错误 ❌ - Publisher 没有默认构造函数，不能直接声明
rclcpp::Publisher<status_interface::msg::SystemStatus> publisher_;

// 正确 ✅ - 必须声明为智能指针
rclcpp::Publisher<status_interface::msg::SystemStatus>::SharedPtr publisher_;
```

**原因**：
- `create_publisher()` 返回的是 `SharedPtr`（智能指针）
- Publisher 对象不能直接实例化，必须通过 Node 的方法创建
- Timer、Subscription 等也是同样的道理，都要用 `::SharedPtr`

### 1.5 C++ 冒号符号区别

| 符号 | 名称 | 用途 | 记忆方法 |
|------|------|------|---------|
| `:` | 单冒号 | 继承、初始化列表 | "继承自" 或 "初始化" |
| `::` | 双冒号（作用域解析符） | 访问命名空间/类成员 | "里面的"（像文件夹路径） |

**具体例子：**

```cpp
// `:` 单冒号 - 表示继承关系
class SysStatusPub : public rclcpp::Node
//                 ↑ 继承

// `::` 双冒号 - 表示"里面的"
rclcpp::Node        // rclcpp 命名空间里面的 Node
std::string         // std 命名空间里面的 string
status_interface::msg::SystemStatus  // status_interface -> msg -> SystemStatus

// 构造函数初始化列表也用 `:`
SysStatusPub() : Node("node_name")
//             ↑ 初始化列表
{
}
```

**常见错误：**

```cpp
// 错误 ❌ (把继承的 : 写成了 ::)
class SysStatusPub::public rclcpp::Node

// 正确 ✅
class SysStatusPub : public rclcpp::Node
```

---

## 2. Python 与 C++ 对照

| Python | C++ 头文件 |
|--------|-----------|
| `from rclpy.node import Node` | `#include "rclcpp/rclcpp.hpp"` |
| `import psutil` | 无直接对应，需手动实现 |
| `import platform` | 无直接对应，用系统调用 |

---

## 3. 系统信息获取（C++ 实现）

### 3.1 消息定义 (SystemStatus.msg)

```
builtin_interfaces/Time stamp
string host_name
float32 cpu_percent
float32 memory_percent
float32 memory_total
float32 memory_available
float64 net_sent
float64 net_recv
```

### 3.2 C++ 所需头文件

```cpp
#include "rclcpp/rclcpp.hpp"
#include "status_interface/msg/system_status.hpp"

#include <unistd.h>       // gethostname() - 获取主机名
#include <sys/sysinfo.h>  // sysinfo() - 内存信息
#include <fstream>        // 读取 /proc/ 文件系统
#include <string>
```

### 3.3 各字段获取方式

| 字段 | 获取方式 | 说明 |
|------|---------|------|
| `stamp` | `this->now()` | ROS2 时间戳 |
| `host_name` | `gethostname()` | 系统调用 |
| `cpu_percent` | 读取 `/proc/stat` | 需要计算两次采样的差值 |
| `memory_percent` | `sysinfo()` 计算 | `(total - free) / total * 100` |
| `memory_total` | `sysinfo().totalram` | 单位：字节 |
| `memory_available` | `/proc/meminfo` 的 `MemAvailable` | `sysinfo()` 没有直接提供 |
| `net_sent` | `/proc/net/dev` | 累计发送字节数 |
| `net_recv` | `/proc/net/dev` | 累计接收字节数 |

### 3.4 关键 Linux 文件

- `/proc/stat` - CPU 统计信息
- `/proc/meminfo` - 内存详细信息
- `/proc/net/dev` - 网络接口统计
- `/etc/hostname` - 主机名（备选）

### 3.5 定时器回调函数绑定

```cpp
// 错误 ❌ - 成员函数不能直接传
timer_ = this->create_wall_timer(1s, this->timer_callback);

// 正确 ✅ - 用 std::bind 绑定 this 指针
timer_ = this->create_wall_timer(1000ms, std::bind(&SysStatusPub::timer_callback, this));

// 正确 ✅ - 用 lambda 表达式
timer_ = this->create_wall_timer(1000ms, [this]() { this->timer_callback(); });
```

**原因**：成员函数需要知道是哪个对象在调用（`this` 指针）

### 3.6 RCLCPP_INFO 日志打印

```cpp
// 基本用法
RCLCPP_INFO(this->get_logger(), "Hello ROS2!");

// 打印变量 - C 风格格式符
RCLCPP_INFO(this->get_logger(), "主机: %s", msg.host_name.c_str());
RCLCPP_INFO(this->get_logger(), "CPU使用率: %.1f%%", msg.cpu_percent);
RCLCPP_INFO(this->get_logger(), "内存: %.2f MB", msg.memory_total);
```

**格式符对照：**

| 格式符 | 类型 | 说明 |
|-------|------|------|
| `%s` | char* | 字符串，std::string 需要 `.c_str()` |
| `%d` | int | 整数 |
| `%f` | float/double | 浮点数 |
| `%.2f` | float/double | 保留2位小数 |
| `%%` | - | 打印 % 符号本身 |

### 3.7 CPU 使用率获取（完整实现）

CPU 使用率需要**两次采样计算差值**：

```cpp
class SysStatusPub : public rclcpp::Node
{
private:
    // 保存上一次的 CPU 时间值
    long prev_idle_ = 0;
    long prev_total_ = 0;

    // 读取 /proc/stat 获取 CPU 时间
    void get_cpu_times(long &idle, long &total)
    {
        std::ifstream file("/proc/stat");
        std::string cpu;
        long user, nice, system, idle_time, iowait, irq, softirq, steal;

        file >> cpu >> user >> nice >> system >> idle_time >> iowait >> irq >> softirq >> steal;

        idle = idle_time + iowait;
        total = user + nice + system + idle_time + iowait + irq + softirq + steal;
    }

    // 计算 CPU 使用率
    float get_cpu_percent()
    {
        long idle, total;
        get_cpu_times(idle, total);

        // 第一次调用，没有上次数据
        if (prev_total_ == 0)
        {
            prev_idle_ = idle;
            prev_total_ = total;
            return 0.0;
        }

        long idle_diff = idle - prev_idle_;
        long total_diff = total - prev_total_;

        prev_idle_ = idle;
        prev_total_ = total;

        if (total_diff == 0) return 0.0;

        // CPU使用率 = 1 - (空闲时间差 / 总时间差)
        return (1.0 - (float)idle_diff / total_diff) * 100.0;
    }
};
```

### 3.8 网络流量获取（完整实现）

```cpp
#include <sstream>  // 需要添加这个头文件

void get_net_info(double &net_recv, double &net_sent)
{
    std::ifstream file("/proc/net/dev");
    std::string line;
    net_recv = 0;
    net_sent = 0;

    while (std::getline(file, line))
    {
        // 跳过标题行和回环接口 lo
        if (line.find("lo:") != std::string::npos ||
            line.find("|") != std::string::npos ||
            line.find("Inter") != std::string::npos)
            continue;

        if (line.find(":") != std::string::npos)
        {
            // 去掉接口名，只保留数据部分
            std::istringstream iss(line.substr(line.find(":") + 1));
            double recv, sent, tmp;

            // /proc/net/dev 格式：
            // 接收字节 包数 错误 丢弃 ... 发送字节(第9个字段)
            iss >> recv;  // 第1个：接收字节
            for (int i = 0; i < 7; i++) iss >> tmp;  // 跳过 2-8
            iss >> sent;  // 第9个：发送字节

            net_recv += recv;
            net_sent += sent;
        }
    }

    // 转换为 MB
    net_recv = net_recv / 1024.0 / 1024.0;
    net_sent = net_sent / 1024.0 / 1024.0;
}
```

### 3.9 消息字段赋值

```cpp
void timer_callback()
{
    auto msg = status_interface::msg::SystemStatus();

    // 1. 时间戳
    msg.stamp = this->now();

    // 2. 主机名
    char hostname[256];
    gethostname(hostname, sizeof(hostname));
    msg.host_name = std::string(hostname);

    // 3. 内存信息
    struct sysinfo si;
    sysinfo(&si);
    msg.memory_total = si.totalram / 1024.0 / 1024.0;      // MB
    msg.memory_available = si.freeram / 1024.0 / 1024.0;   // MB
    msg.memory_percent = (1.0 - (float)si.freeram / si.totalram) * 100;

    // 4. CPU 使用率
    msg.cpu_percent = get_cpu_percent();

    // 5. 网络流量
    double net_recv, net_sent;
    get_net_info(net_recv, net_sent);
    msg.net_recv = net_recv;
    msg.net_sent = net_sent;

    // 发布消息
    publisher_->publish(msg);
}
```

---

## 4. CMake 配置要点

### 4.1 package.xml 依赖声明

```xml
<depend>rclcpp</depend>
<depend>status_interface</depend>  <!-- 自定义消息包必须声明 -->
```

### 4.2 CMakeLists.txt 关键配置

```cmake
# 查找依赖
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(status_interface REQUIRED)

# 创建可执行文件 - 注意是 add_executable 不是 add_dependencies
add_executable(sys_status_pub src/sys_status_pub.cpp)

# 链接依赖
ament_target_dependencies(sys_status_pub rclcpp status_interface)

# 安装
install(TARGETS sys_status_pub
  DESTINATION lib/${PROJECT_NAME}
)
```

**常见错误**：
```cmake
# 错误 ❌
add_dependencies(sys_status_pub src/sys_status_pub.cpp)

# 正确 ✅
add_executable(sys_status_pub src/sys_status_pub.cpp)
```

---

## 5. 运行命令

```bash
# 编译
cd /home/gan/ros2_chapt3/topic_pra_ws
colcon build

# source 环境
source install/setup.bash

# 运行节点
ros2 run status_publihser sys_status_pub

# 另开终端查看话题
ros2 topic echo /sys_status
```

---

## 6. 常见错误总结

| 错误 | 原因 | 解决方案 |
|------|------|---------|
| 找不到头文件 | 路径配置指向 `src/` | 改为 `install/` 目录 |
| 拼写错误 | `staus` 少了字母 | 检查拼写：`status` |
| 编译后还是报错 | 没有 source 环境 | `source install/setup.bash` |
| `The message type is invalid` | 新终端没有 source | 每个终端都要 source |
| `add_dependencies` 报错 | 应该用 `add_executable` | 改成 `add_executable` |
| `Findxxx.cmake` 找不到 | package.xml 缺少依赖 | 添加 `<depend>包名</depend>` |

---

## 7. 重要：终端环境配置

### 7.1 每个新终端都需要 source

```bash
# 问题：新终端执行 ros2 topic echo 报错
ros2 topic echo /sys_status
# The message type 'status_interface/msg/SystemStatus' is invalid

# 原因：新终端没有 source 工作空间环境
# 解决：先 source 再执行命令
cd /home/gan/ros2_chapt3/topic_pra_ws
source install/setup.bash
ros2 topic echo /sys_status  # 现在可以了
```

### 7.2 自动 source（推荐）

把 source 命令加到 `~/.bashrc`，这样每次开终端自动执行：

```bash
echo "source /home/gan/ros2_chapt3/topic_pra_ws/install/setup.bash" >> ~/.bashrc
```

**注意**：如果有多个工作空间，后 source 的会覆盖前面的同名包

---

*笔记更新时间：2025-12-06*
